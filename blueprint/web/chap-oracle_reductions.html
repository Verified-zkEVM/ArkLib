<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Oracle Reductions</title>
<link rel="next" href="chap-proof_systems.html" title="Proof Systems" />
<link rel="prev" href="sect0001.html" title="Introduction" />
<link rel="up" href="index.html" title="Formally Verified Arguments of Knowledge in Lean" />
<link rel="stylesheet" href="styles/theme-white.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/pygments.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/extra_styles.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Formally Verified Arguments of Knowledge in Lean</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class=" active current">
  <a href="chap-oracle_reductions.html"><span class="toc_ref">2</span> <span class="toc_entry">Oracle Reductions</span></a>
  <span class="expand-toc">▼</span>
  <ul class="sub-toc-1 active">
     <li class="">
  <a href="chap-oracle_reductions.html#sec:oracle_reductions_defs"><span class="toc_ref">2.1</span> <span class="toc_entry">Definitions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-oracle_reductions.html#sec:oracle_reductions_defs_format"><span class="toc_ref">2.1.1</span> <span class="toc_entry">Format</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000004"><span class="toc_ref">2.1.2</span> <span class="toc_entry">Security properties</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000005"><span class="toc_ref">2.2</span> <span class="toc_entry">A Program Logic for Oracle Reductions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-oracle_reductions.html#a0000000006"><span class="toc_ref">2.2.1</span> <span class="toc_entry">Changing Relations and Oracles</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000007"><span class="toc_ref">2.2.2</span> <span class="toc_entry">Sequential Composition</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000008"><span class="toc_ref">2.2.3</span> <span class="toc_entry">Virtualization</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000009"><span class="toc_ref">2.2.4</span> <span class="toc_entry">Substitution</span></a>
 </li>

  </ul>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-proof_systems.html"><span class="toc_ref">3</span> <span class="toc_entry">Proof Systems</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-proof_systems.html#a0000000010"><span class="toc_ref">3.1</span> <span class="toc_entry">Simple Oracle Reductions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-proof_systems.html#a0000000011"><span class="toc_ref">3.1.1</span> <span class="toc_entry">Polynomial Equality Testing</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000012"><span class="toc_ref">3.1.2</span> <span class="toc_entry">Batching Polynomial Evaluation Claims</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-proof_systems.html#sec:sumcheck"><span class="toc_ref">3.2</span> <span class="toc_entry">The Sum-Check Protocol</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-proof_systems.html#sec:sumcheck_standard"><span class="toc_ref">3.2.1</span> <span class="toc_entry">Standard Description</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#sec:sumcheck_modular"><span class="toc_ref">3.2.2</span> <span class="toc_entry">Modular Description</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000013"><span class="toc_ref">3.3</span> <span class="toc_entry">The Spartan Protocol</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000014"><span class="toc_ref">3.4</span> <span class="toc_entry">The Ligero Polynomial Commitment Scheme</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-commitment_schemes.html"><span class="toc_ref">4</span> <span class="toc_entry">Commitment Schemes</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-commitment_schemes.html#a0000000015"><span class="toc_ref">4.1</span> <span class="toc_entry">Definitions</span></a>
 </li>
<li class="">
  <a href="chap-commitment_schemes.html#sec:merkle_trees"><span class="toc_ref">4.2</span> <span class="toc_entry">Merkle Trees</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-supporting_theories.html"><span class="toc_ref">5</span> <span class="toc_entry">Supporting Theories</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-supporting_theories.html#sec:polynomials"><span class="toc_ref">5.1</span> <span class="toc_entry">Polynomials</span></a>
 </li>
<li class="">
  <a href="chap-supporting_theories.html#sec:coding_theory"><span class="toc_ref">5.2</span> <span class="toc_entry">Coding Theory</span></a>
 </li>
<li class="">
  <a href="chap-supporting_theories.html#sec:vcvio"><span class="toc_ref">5.3</span> <span class="toc_entry">The VCVio Library</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-references.html"><span class="toc_ref">6</span> <span class="toc_entry">References</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">7</span> <span class="toc_entry">Bibliography</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="chap:oracle_reductions">2 Oracle Reductions</h1>

<h1 id="sec:oracle_reductions_defs">2.1 Definitions</h1>

<p>In this section, we give the basic definitions of a public-coin interactive oracle reduction (henceforth called an oracle reduction or IOR). We will define its building blocks, and various security properties. </p>
<h2 id="sec:oracle_reductions_defs_format">2.1.1 Format</h2>

<p>An <b class="bfseries">(interactive) oracle reduction (IOR)</b> is an interactive protocol between two parties, a <em>prover</em> \(\mathcal{P}\) and a <em>verifier</em> \(\mathcal{V}\). In ArkLib, IORs are defined in the following setting: </p>
<ol class="enumerate">
  <li><p>We work in an ambient dependent type theory (in our case, Lean). </p>
</li>
  <li><p>The protocol flow is fixed and defined by a given <em>type signature</em>, which describes in each round which party sends a message to the other, and the type of that message. </p>
</li>
  <li><p>The prover and verifier has access to some inputs (called the <em>(oracle) context</em>) at the beginning of the protocol. These inputs are classified as follows: </p>
<ul class="itemize">
  <li><p><em>Public inputs</em> (or <em>statement</em>) \(\mathbbm {x}\): available to both parties; </p>
</li>
  <li><p><em>Private inputs</em> (or <em>witness</em>) \(\mathbbm {w}\): available only to the prover; </p>
</li>
  <li><p><em>Oracle inputs</em> (or <em>oracle statement</em>) \(\mathbbm {ox}\): the underlying data is available to the prover, but it’s only exposed as an oracle to the verifier. See&#160;<a href="chap-oracle_reductions.html#def:oracle_interface">Definition 2</a> for more information. </p>
</li>
  <li><p><em>Shared oracle</em> \(\mathcal{O}\): the oracle is available to both parties via an interface; in most cases, it is either empty, a probabilistic sampling oracle, a random oracle, or a group oracle (for the Algebraic Group Model). See&#160;<a href="chap-supporting_theories.html#sec:vcvio">Section 5.3</a> for more information on oracle computations. </p>
</li>
</ul>
</li>
  <li><p>The messages sent from the prover may either: 1) be seen directly by the verifier, or 2) only available to a verifier through an <em>oracle interface</em> (which specifies the type for the query and response, and the oracle’s behavior given the underlying message). </p>
<p>Currently, in the oracle reduction setting, we <em>only</em> allow messages sent to be available through oracle interfaces. In the (non-oracle) reduction setting, all messages are available directly. Future extensions may allow for mixed visibility for prover’s messages. </p>
</li>
  <li><p>\(\mathcal{V}\) is assumed to be <em>public-coin</em>, meaning that its challenges are chosen uniformly at random from the finite type corresponding to that round, and it uses no randomness otherwise, except from those coming from the shared oracle. </p>
</li>
  <li><p>At the end of the protocol, the prover and verifier outputs a new (oracle) context, which consists of: </p>
<ul class="itemize">
  <li><p>The verifier takes in the input statement and the challenges, performs an <em>oracle</em> computation on the input oracle statements and the oracle messages, and outputs a new output statement. </p>
<p>The verifier also outputs the new oracle statement in an implicit manner, by specifying a subset of the input oracle statements &amp; the oracle messages. Future extensions may allow for more flexibility in specifying output oracle statements (i.e. not just a subset, but a linear combination, or any other function). </p>
</li>
  <li><p>The prover takes in some final private state (maintained during protocol execution), and outputs a new output statement, new output oracle statement, and new output witness. </p>
</li>
</ul>
</li>
</ol>
<div class="remark_thmwrapper theorem-style-definition" id="a0000000016">
  <div class="remark_thmheading">
    <span class="remark_thmcaption">
    Remark
    </span>
    <span class="remark_thmlabel">1</span>
    <span class="remark_thmtitle">Literature Comparison</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#a0000000016">#</a>
    
    
    
        </div>
  </div>
  <div class="remark_thmcontent">
  <p> In the literature, our definition corresponds to the notion of <em>functional</em> IORs. Historically, (vector) IOPs were the first notion to be introduced by&#160;<span class="cite">
	[
</span>; these are IORs where the output statement is true/false, all oracle statements and messages are vectors over some alphabet \(\Sigma \), and the oracle interfaces are for querying specific positions in the vector. More recent works have considered other oracle interfaces, e.g., polynomial oracles&#160;<span class="cite">
	[
</span>, generalized proofs to reductions&#160;<span class="cite">
	[
</span>, and considered general oracle interfaces&#160;<span class="cite">
	[
</span>. Most of the IOP theory has been distilled in the textbook&#160;<span class="cite">
	[
</span>. </p>
<p>We have not seen any work that considers our most general setting, of IORs with arbitrary oracle interfaces. </p>

  </div>
</div>
<p>We now go into more details on these objects, and how they are represented in Lean. Our description will aim to be as close as possible to the Lean code, and hence may differ somewhat from “mainstream” mathematical &amp; cryptographic notation. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:oracle_interface">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">2</span>
    <span class="definition_thmtitle">Oracle Interface</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:oracle_interface">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleInterface" class="lean_decl">OracleInterface</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  An oracle interface for an underlying data type \(\mathsf{D}\) consists of the following: </p>
<ul class="itemize">
  <li><p>A type \(\mathsf{Q}\) for queries to the oracle, </p>
</li>
  <li><p>A type \(\mathsf{R}\) for responses from the oracle, </p>
</li>
  <li><p>A function \(\mathsf{oracle} : \mathsf{D} \to \mathsf{Q} \to \mathsf{R}\) that specifies the oracle’s behavior given the underlying data and a query. </p>
</li>
</ul>


  </div>
</div>
<p>See <span class="ttfamily">OracleInterface.lean</span> for common instances of \(\mathsf{OracleInterface}\). </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:context">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3</span>
    <span class="definition_thmtitle">Context</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:context">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  In an (oracle) reduction, its <em>(oracle) context</em> consists of a statement type, a witness type, and (in the oracle case) an indexed list of oracle statement types. </p>
<p>Currently, we do not abstract out / bundle the context as a separate structure, but rather specifies the types explicitly. This may change in the future. </p>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:protocol_spec">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">4</span>
    <span class="definition_thmtitle">Protocol Specification</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:protocol_spec">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec" class="lean_decl">ProtocolSpec</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  A protocol specification for an \(n\)-message (oracle) reduction, is an element of the following type: <div class="displaymath" id="a0000000017">
  
</div> ProtocolSpec n := Fin n Direction×Type. <div class="displaymath" id="a0000000018">
  
</div> In the above, \(\mathsf{Direction}:= \{  \mathsf{P \! \! \rightarrow \! \!  V}, \mathsf{V \! \! \rightarrow \! \!  P}\} \) is the type of possible directions of messages, and \(\mathsf{Fin}\  n := \{  i : \mathbb {N}\mathbin {/\! /}i {\lt} n \} \) is the type of all natural numbers less than \(n\). </p>
<p>In other words, for each step \(i\) of interaction, the protocol specification describes the <em>direction</em> of the message sent in that step, i.e., whether it is from the prover or from the verifier. It also describes the <em>type</em> of that message. </p>
<p>In the oracle setting, we also expect an oracle interface for each message from the prover to the verifier.  </p>

  </div>
</div>
<p>We define some supporting definitions for a protocol specification. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:protocol_spec_components">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">5</span>
    <span class="definition_thmtitle">Protocol Specification Components</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:protocol_spec_components">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:protocol_spec">Definition 4</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Dir" class="lean_decl">ProtocolSpec.Dir</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.getType" class="lean_decl">ProtocolSpec.getType</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.MessageIdx" class="lean_decl">ProtocolSpec.MessageIdx</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.ChallengeIdx" class="lean_decl">ProtocolSpec.ChallengeIdx</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Message" class="lean_decl">ProtocolSpec.Message</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Challenge" class="lean_decl">ProtocolSpec.Challenge</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  Given a protocol specification \(\mathsf{pSpec}: \mathsf{ProtocolSpec}\  n\), we define: </p>
<ul class="itemize">
  <li><p>\(\mathsf{pSpec}.\mathsf{Dir}\  i := (\mathsf{pSpec}\  i).\mathsf{fst}\) extracts the direction of the \(i\)-th message. </p>
</li>
  <li><p>\(\mathsf{pSpec}.\mathsf{Type}\  i := (\mathsf{pSpec}\  i).\mathsf{snd}\) extracts the type of the \(i\)-th message. </p>
</li>
  <li><p>\(\mathsf{pSpec}.\mathsf{MessageIdx}:= \{ i : \mathsf{Fin}\  n \mathbin {/\! /}\mathsf{pSpec}.\mathsf{Dir}\  i = \mathsf{P \! \! \rightarrow \! \!  V}\} \) is the subtype of indices corresponding to prover messages. </p>
</li>
  <li><p>\(\mathsf{pSpec}.\mathsf{ChallengeIdx}:= \{ i : \mathsf{Fin}\  n \mathbin {/\! /}\mathsf{pSpec}.\mathsf{Dir}\  i = \mathsf{V \! \! \rightarrow \! \!  P}\} \) is the subtype of indices corresponding to verifier challenges. </p>
</li>
  <li><p>\(\mathsf{pSpec}.\mathsf{Message}\  i := (i : \mathsf{pSpec}.\mathsf{MessageIdx}) \to \mathsf{pSpec}.\mathsf{Type}\  i.\mathsf{val}\) is an indexed family of message types in the protocol. </p>
</li>
  <li><p>\(\mathsf{pSpec}.\mathsf{Challenge}\  i := (i : \mathsf{pSpec}.\mathsf{ChallengeIdx}) \to \mathsf{pSpec}.\mathsf{Type}\  i.\mathsf{val}\) is an indexed family of challenge types in the protocol. </p>
</li>
</ul>


  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:transcript">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">6</span>
    <span class="definition_thmtitle">Protocol Transcript</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:transcript">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:protocol_spec">Definition 4</a></li>
          
          <li><a href="chap-oracle_reductions.html#def:protocol_spec_components">Definition 5</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Transcript" class="lean_decl">ProtocolSpec.Transcript</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Message" class="lean_decl">ProtocolSpec.Message</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Challenge" class="lean_decl">ProtocolSpec.Challenge</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  Given protocol specification \(\mathsf{pSpec}: \mathsf{ProtocolSpec}\  n\), we define: </p>
<ul class="itemize">
  <li><p>A <em>transcript</em> up to round \(k : \mathsf{Fin}\  (n + 1)\) is an element of type </p>
<div class="displaymath" id="a0000000019">
  \[  \mathsf{Transcript}\  k\  \mathsf{pSpec}:= (i : \mathsf{Fin}\  k) \to \mathsf{pSpec}.\mathsf{Type}\  (\uparrow i : \mathsf{Fin}\  n)  \]
</div>
<p> where \(\uparrow i : \mathsf{Fin}\  n\) denotes casting \(i : \mathsf{Fin}\  k\) to \(\mathsf{Fin}\  n\) (valid since \(k \leq n + 1\)). </p>
</li>
  <li><p>A <em>full transcript</em> is \(\mathsf{FullTranscript}\  \mathsf{pSpec}:= (i : \mathsf{Fin}\  n) \to \mathsf{pSpec}.\mathsf{Type}\  i\). </p>
</li>
  <li><p>The type of all <em>messages</em> from prover to verifier is </p>
<div class="displaymath" id="a0000000020">
  \[  \mathsf{pSpec}.\mathsf{Messages}:= \prod _{i : \mathsf{pSpec}.\mathsf{MessageIdx}} \mathsf{pSpec}.\mathsf{Message}\  i  \]
</div>
</li>
  <li><p>The type of all <em>challenges</em> from verifier to prover is </p>
<div class="displaymath" id="a0000000021">
  \[  \mathsf{pSpec}.\mathsf{Challenges}:= \prod _{i : \mathsf{pSpec}.\mathsf{ChallengeIdx}} \mathsf{pSpec}.\mathsf{Challenge}\  i  \]
</div>
</li>
</ul>


  </div>
</div>
<div class="remark_thmwrapper theorem-style-definition" id="a0000000022">
  <div class="remark_thmheading">
    <span class="remark_thmcaption">
    Remark
    </span>
    <span class="remark_thmlabel">7</span>
    <span class="remark_thmtitle">Design Decision</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#a0000000022">#</a>
    
    
    
        </div>
  </div>
  <div class="remark_thmcontent">
  <p> We do not enforce a particular interaction flow in the definition of an interactive (oracle) reduction. This is done so that we can capture all protocols in the most generality. Also, we want to allow the prover to send multiple messages in a row, since each message may have a different oracle representation (for instance, in the Plonk protocol, the prover’s first message is a 3-tuple of polynomial commitments.) </p>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:prover">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">8</span>
    <span class="definition_thmtitle">Type Signature of a Prover</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:prover">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Prover" class="lean_decl">Prover</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  A prover \(\mathcal{P}\) in a reduction, given a context, is a stateful oracle computation that at each step of the protocol, either takes in a new message from the verifier, or sends a new message to the verifier.  </p>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:oracle_prover">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">9</span>
    <span class="definition_thmtitle">Type Signature of an Oracle Prover</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:oracle_prover">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleProver" class="lean_decl">OracleProver</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>After the interaction phase, the verifier may then run some verification procedure to check the validity of the prover’s responses. In this procedure, the verifier gets access to the public part of the context, and oracle access to either the shared oracle, or the oracle inputs. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:verifier">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">10</span>
    <span class="definition_thmtitle">Type Signature of a Verifier</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:verifier">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Verifier" class="lean_decl">Verifier</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  A verifier \(\mathcal{V}\) in an oracle reduction is an oracle computation that may perform a series of checks (i.e. ‘Bool‘-valued, or ‘Option Unit‘) on the given context.  </p>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:oracle_verifier">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">11</span>
    <span class="definition_thmtitle">Type Signature of an Oracle Verifier</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:oracle_verifier">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleVerifier" class="lean_decl">OracleVerifier</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>An oracle reduction then consists of a type signature for the interaction, and a pair of prover and verifier for that type signature. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:interactive_reduction">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">12</span>
    <span class="definition_thmtitle">Interactive Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:interactive_reduction">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:prover">Definition 8</a></li>
          
          <li><a href="chap-oracle_reductions.html#def:verifier">Definition 10</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction" class="lean_decl">Reduction</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>   An interactive reduction is a combination of a type signature <code class="verbatim">ProtocolSpec</code>, a prover for <code class="verbatim">ProtocolSpec</code>, and a verifier for <code class="verbatim">ProtocolSpec</code>.  </p>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:interactive_oracle_reduction">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">13</span>
    <span class="definition_thmtitle">Interactive Oracle Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:interactive_oracle_reduction">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:oracle_prover">Definition 9</a></li>
          
          <li><a href="chap-oracle_reductions.html#def:oracle_verifier">Definition 11</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleReduction" class="lean_decl">OracleReduction</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>   An interactive oracle reduction for a given context \(\Gamma \) is a combination a prover and a verifier of the types specified above.  </p>

  </div>
</div>
<p>We now define what it means to execute an oracle reduction. This is essentially achieved by first executing the prover, interspersed with oracle queries to get the verifier’s challenges (these will be given uniform random probability semantics later on), and then executing the verifier’s checks. Any message exchanged in the protocol will be added to the context. We may also log information about the execution, such as the log of oracle queries for the shared oracles, for analysis purposes (i.e. feeding information into the extractor). </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:oracle_reduction_execution">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">14</span>
    <span class="definition_thmtitle">Execution of an Oracle Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:oracle_reduction_execution">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleReduction.run" class="lean_decl">OracleReduction.run</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<h2 id="a0000000004">2.1.2 Security properties</h2>
<p>We can now define properties of interactive reductions. The two main properties we consider in this project are completeness and various notions of soundness. We will cover zero-knowledge at a later stage. </p>
<p>First, for completeness, this is essentially probabilistic Hoare-style conditions on the execution of the oracle reduction (with the honest prover and verifier). In other words, given a predicate on the initial context, and a predicate on the final context, we require that if the initial predicate holds, then the final predicate holds with high probability (except for some <em>completeness</em> error). </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:completeness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">15</span>
    <span class="definition_thmtitle">Completeness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:completeness">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:interactive_oracle_reduction">Definition 13</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction.completeness" class="lean_decl">Reduction.completeness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>Almost all oracle reductions we consider actually satisfy <em>perfect completeness</em>, which simplifies the proof obligation. In particular, this means we only need to show that no matter what challenges are chosen, the verifier will always accept given messages from the honest prover. </p>
<p>For soundness, we need to consider different notions. These notions differ in two main aspects: </p>
<ul class="itemize">
  <li><p>Whether we consider the plain soundness, or knowledge soundness. The latter relies on the notion of an <em>extractor</em>. </p>
</li>
  <li><p>Whether we consider plain, state-restoration, round-by-round, or rewinding notion of soundness. </p>
</li>
</ul>
<p>We note that state-restoration knowledge soundness is necessary for the security of the SNARK protocol obtained from the oracle reduction after composing with a commitment scheme and applying the Fiat-Shamir transform. It in turn is implied by either round-by-round knowledge soundness, or special soundness (via rewinding). At the moment, we only care about non-rewinding soundness, so mostly we will care about round-by-round knowledge soundness. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">16</span>
    <span class="definition_thmtitle">Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:soundness">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:interactive_oracle_reduction">Definition 13</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Verifier.soundness" class="lean_decl">Verifier.soundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>A (straightline) extractor for knowledge soundness is a deterministic algorithm that takes in the output public context after executing the oracle reduction, the side information (i.e. log of oracle queries from the malicious prover) observed during execution, and outputs the witness for the input context. </p>
<p>Note that since we assume the context is append-only, and we append only the public (or oracle) messages obtained during protocol execution, it follows that the witness stays the same throughout the execution. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:knowledge_soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">17</span>
    <span class="definition_thmtitle">Knowledge Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:knowledge_soundness">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:interactive_oracle_reduction">Definition 13</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Verifier.knowledgeSoundness" class="lean_decl">Verifier.knowledgeSoundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>To define round-by-round (knowledge) soundness, we need to define the notion of a <em>state function</em>. This is a (possibly inefficient) function \(\mathsf{StateF}\) that, for every challenge sent by the verifier, takes in the transcript of the protocol so far and outputs whether the state is doomed or not. Roughly speaking, the requirement of round-by-round soundness is that, for any (possibly malicious) prover \(P\), if the state function outputs that the state is doomed on some partial transcript of the protocol, then the verifier will reject with high probability. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:state_function">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">18</span>
    <span class="definition_thmtitle">State Function</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:state_function">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Verifier.StateFunction" class="lean_decl">Verifier.StateFunction</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:round_by_round_soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">19</span>
    <span class="definition_thmtitle">Round-by-Round Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:round_by_round_soundness">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:interactive_oracle_reduction">Definition 13</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Verifier.rbrSoundness" class="lean_decl">Verifier.rbrSoundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:round_by_round_knowledge_soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">20</span>
    <span class="definition_thmtitle">Round-by-Round Knowledge Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:round_by_round_knowledge_soundness">#</a>
    
    
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="chap-oracle_reductions.html#def:interactive_oracle_reduction">Definition 13</a></li>
          
        </ul>
    
      </div>
    </div>

    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Verifier.rbrKnowledgeSoundness" class="lean_decl">Verifier.rbrKnowledgeSoundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<h1 id="a0000000005">2.2 A Program Logic for Oracle Reductions</h1>
<p>In this section, we describe a program logic for reasoning about oracle reductions. In other words, we define a number of rules (or theorems) that govern how oracle reductions can be composed to form larger reductions, and how the resulting reduction inherits the security properties of the components. </p>
<p>The first group of rules changes relations and shared oracles. </p>
<h2 id="a0000000006">2.2.1 Changing Relations and Oracles</h2>
<p>Here we express the consequence rule. Namely, if we have an oracle reduction for \(\mathcal{R}_1 \implies \mathcal{R}_2\), along with \(\mathcal{R}_1' \implies \mathcal{R}_1\) and \(\mathcal{R}_2 \implies \mathcal{R}_2'\), then we obtain an oracle reduction for \(\mathcal{R}_1' \implies \mathcal{R}_2'\). </p>
<div class="displaymath" id="a0000000023">
  \[  \frac{\begin{array}{c} \Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\} \;  \langle \mathcal{P},\,  \mathcal{V},\,  \mathcal{E}\rangle ^{\mathcal{O}} : \tau \; \{ \! \! \{ \mathcal{R}_2; \, \mathsf{St};\,  \epsilon \} \! \! \}  \\[1.5ex] \mathcal{R}_1’ \implies \mathcal{R}_1 \\[1.5ex] \mathcal{R}_2 \implies \mathcal{R}_2’ \end{array}}{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1'\} \;  \langle \mathcal{P},\,  \mathcal{V},\,  \mathcal{E}\rangle ^{\mathcal{O}} : \tau \; \{ \! \! \{ \mathcal{R}_2'; \, \mathsf{St};\,  \epsilon \} \! \! \}  } \quad \text{(Conseq)}  \]
</div>
<div class="displaymath" id="a0000000024">
  \[  \frac{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  }{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R} \times \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R} \times \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  } \quad \text{(Frame)}  \]
</div>
<div class="displaymath" id="a0000000025">
  \[  \frac{\begin{array}{c} \Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}_1} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  \\[1.5ex] \mathcal{O}_1 \subset \mathcal{O}_2 \end{array}}{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}_2} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  } \quad \text{(Oracle-Lift)}  \]
</div>
<p>TODO: figure out how the state function needs to change for these rules (they are basically the same, but not exactly) </p>
<h2 id="a0000000007">2.2.2 Sequential Composition</h2>
<p>The reason why we consider interactive (oracle) reductions at the core of our formalism is that we can <em>compose</em> these reductions to form larger reductions. Equivalently, we can take a complex <em>interactive (oracle) proof</em> (which differs only in that it reduces a relation to the <em>trivial</em> relation that always outputs true) and break it down into a series of smaller reductions. The advantage of this approach is that we can prove security properties (completeness and soundness) for each of the smaller reductions, and these properties will automatically transfer to the larger reductions. </p>
<p>This section is devoted to the composition of interactive (oracle) reductions, and proofs that the resulting reductions inherit the security properties of the two (or more) constituent reductions. </p>
<p>Sequential composition can be expressed as the folowing rule: </p>
<div class="displaymath" id="a0000000026">
  \[  \frac{\begin{array}{c} \Psi ; \Theta ; \varSigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}_1, \mathcal{V}_1, \mathcal{E}_1\rangle ^{\mathcal{O}} : \tau _1 \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}_1; \epsilon _1\} \! \! \}  \\[1.5ex] \Psi ; (\Theta :: \tau _1) ; \varSigma \vdash \{ \mathcal{R}_2\}  \;  \langle \mathcal{P}_2, \mathcal{V}_2, \mathcal{E}_2\rangle ^{\mathcal{O}} : \tau _2 \;  \{ \! \! \{ \mathcal{R}_3; \mathsf{St}_2; \epsilon _2\} \! \! \}  \end{array}}{\Psi ; (\Theta :: \tau _1 :: \tau _2) \  ; \varSigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}_1 \circ \mathcal{P}_2, \mathcal{V}_1 \circ \mathcal{V}_2, \mathcal{E}_1 \circ _{\mathcal{V}_2} \mathcal{E}_2\rangle ^{\mathcal{O}} : \tau _1 \oplus \tau _2 \;  \{ \! \! \{ \mathcal{R}_3; \mathsf{St}_1 \oplus \mathsf{St}_2; \epsilon _1 \oplus \epsilon _2\} \! \! \}  } \quad \text{(Seq-Comp)}  \]
</div>
<h2 id="a0000000008">2.2.3 Virtualization</h2>
<p>Another tool we will repeatedly use is the ability to change the context of an oracle reduction. This is often needed when we want to adapt an oracle reduction in a simple context into one for a more complex context. </p>
<p>See the section on sum-check&#160;<a href="chap-proof_systems.html#sec:sumcheck">3.2</a> for an example. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:virtual_context_mapping">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">21</span>
    <span class="definition_thmtitle">Mapping into Virtual Context</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:virtual_context_mapping">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  In order to apply an oracle reduction on virtual data, we will need to provide a mapping from the current context to the virtual context. This includes: </p>
<ul class="itemize">
  <li><p>A mapping from the current public inputs to the virtual public inputs. </p>
</li>
  <li><p>A simulation of the oracle inputs for the virtual context using the public and oracle inputs for the current context. </p>
</li>
  <li><p>A mapping from the current private inputs to the virtual private inputs. </p>
</li>
  <li><p>A simulation of the shared oracle for the virtual context using the shared oracle for the current context. </p>
</li>
</ul>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:virtual_oracle_reduction">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">22</span>
    <span class="definition_thmtitle">Virtual Oracle Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:virtual_oracle_reduction">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  Given a suitable mapping into a virtual context, we may define an oracle reduction via the following construction: </p>
<ul class="itemize">
  <li><p>The prover first applies the mappings to obtain the virtual context. The verifier does the same, but only for the non-private inputs. </p>
</li>
  <li><p>The prover and verifier then run the virtual oracle reduction on the virtual context. </p>
</li>
</ul>

  </div>
</div>
<p>We will show security properties for this virtualization process. One can see that completeness and soundness are inherited from the completeness and soundness of the virtual oracle reduction. However, (round-by-round) knowledge soundness is more tricky; this is because we must extract back to the witness of the original context from the virtual context. </p>
<div class="displaymath" id="a0000000027">
  \[  \frac{\begin{array}{c} \Psi ’; \Theta ’; \Sigma ’ \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  \\[1.5ex] f : (\Psi , \Theta , \Sigma ) \to (\Psi ’, \Theta ’, \Sigma ’) \\[1.5ex] g : \Psi ’ \to \Psi \\[1.5ex] f.\mathsf{fst} \circ g = \mathsf{id} \end{array}}{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1 \circ f\}  \;  \langle \mathcal{P} \circ f, \mathcal{V} \circ f, \mathcal{E} \circ (f, g)\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R}_2 \circ f; \mathsf{St} \circ f; \epsilon \} \! \! \}  } \quad \text{(Virtual-Ctx)}  \]
</div>
<h2 id="a0000000009">2.2.4 Substitution</h2>
<p>Finally, we need a transformation / inference rule that allows us to change the message type in a given round of an oracle reduction. In other words, we substitute a value in the round with another value, followed by a reduction establishing the relationship between the new and old values. </p>
<p>Examples include: </p>
<ol class="enumerate">
  <li><p>Substituting an oracle input by a public input: </p>
<ul class="itemize">
  <li><p>Often by just revealing the underlying data. This has no change on the prover, and for the verifier, this means that any query to the oracle input can be locally computed. </p>
</li>
  <li><p>A variant of this is when the oracle input consists of a data along with a proof that the data satisfies some predicate. In this case, the verifier needs to additionally check that the predicate holds for the substituted data. </p>
</li>
  <li><p>Another common substitution is to replace a vector with its Merkle commitment, or a polynomial with its polynomial commitment. </p>
</li>
</ul>
</li>
  <li><p>Substituting an oracle input by another oracle input, followed by a reduction for each oracle query the verifier makes to the old oracle: </p>
<ul class="itemize">
  <li><p>This is also a variant of the previous case, where we do not fully substitute with a public input, but do a “half-substitution” by substituting with another oracle input. This happens e.g. when using a polynomial commitment scheme that is itself based on a vector commitment scheme. One can cast protocols like Ligero / Brakedown / FRI / STIR in this two-step process. </p>
</li>
</ul>
</li>
</ol>

</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0001.html" title="Introduction"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Formally Verified Arguments of Knowledge in Lean"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="chap-proof_systems.html" title="Proof Systems"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>