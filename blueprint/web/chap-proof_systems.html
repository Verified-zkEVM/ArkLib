<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Proof Systems</title>
<link rel="next" href="chap-commitment_schemes.html" title="Commitment Schemes" />
<link rel="prev" href="chap-oracle_reductions.html" title="Oracle Reductions" />
<link rel="up" href="index.html" title="Formally Verified SNARKs in Lean" />
<link rel="stylesheet" href="styles/theme-white.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/pygments.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/extra_styles.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Formally Verified SNARKs in Lean</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html"><span class="toc_ref">2</span> <span class="toc_entry">Oracle Reductions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-oracle_reductions.html#a0000000004"><span class="toc_ref">2.1</span> <span class="toc_entry">Definitions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-oracle_reductions.html#a0000000005"><span class="toc_ref">2.1.1</span> <span class="toc_entry">Format</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000006"><span class="toc_ref">2.1.2</span> <span class="toc_entry">Security properties</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000007"><span class="toc_ref">2.2</span> <span class="toc_entry">A Program Logic for Oracle Reductions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-oracle_reductions.html#a0000000008"><span class="toc_ref">2.2.1</span> <span class="toc_entry">Changing Relations and Oracles</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000009"><span class="toc_ref">2.2.2</span> <span class="toc_entry">Sequential Composition</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000010"><span class="toc_ref">2.2.3</span> <span class="toc_entry">Virtualization</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000011"><span class="toc_ref">2.2.4</span> <span class="toc_entry">Substitution</span></a>
 </li>

  </ul>
 </li>

  </ul>
 </li>
<li class=" active current">
  <a href="chap-proof_systems.html"><span class="toc_ref">3</span> <span class="toc_entry">Proof Systems</span></a>
  <span class="expand-toc">▼</span>
  <ul class="sub-toc-1 active">
     <li class="">
  <a href="chap-proof_systems.html#a0000000012"><span class="toc_ref">3.1</span> <span class="toc_entry">Simple Oracle Reductions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-proof_systems.html#a0000000013"><span class="toc_ref">3.1.1</span> <span class="toc_entry">Polynomial Equality Testing</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000014"><span class="toc_ref">3.1.2</span> <span class="toc_entry">Batching Polynomial Evaluation Claims</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-proof_systems.html#sec:sumcheck"><span class="toc_ref">3.2</span> <span class="toc_entry">The Sum-Check Protocol</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000015"><span class="toc_ref">3.3</span> <span class="toc_entry">The Spartan Protocol</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000016"><span class="toc_ref">3.4</span> <span class="toc_entry">The Ligero Polynomial Commitment Scheme</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-commitment_schemes.html"><span class="toc_ref">4</span> <span class="toc_entry">Commitment Schemes</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-commitment_schemes.html#a0000000017"><span class="toc_ref">4.1</span> <span class="toc_entry">Definitions</span></a>
 </li>
<li class="">
  <a href="chap-commitment_schemes.html#sec:merkle_trees"><span class="toc_ref">4.2</span> <span class="toc_entry">Merkle Trees</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-supporting_theories.html"><span class="toc_ref">5</span> <span class="toc_entry">Supporting Theories</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-supporting_theories.html#sec:polynomials"><span class="toc_ref">5.1</span> <span class="toc_entry">Polynomials</span></a>
 </li>
<li class="">
  <a href="chap-supporting_theories.html#sec:coding_theory"><span class="toc_ref">5.2</span> <span class="toc_entry">Coding Theory</span></a>
 </li>
<li class="">
  <a href="chap-supporting_theories.html#sec:vcvio"><span class="toc_ref">5.3</span> <span class="toc_entry">The VCVio Library</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-references.html"><span class="toc_ref">6</span> <span class="toc_entry">References</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">7</span> <span class="toc_entry">Bibliography</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="chap:proof_systems">3 Proof Systems</h1>

<h1 id="a0000000012">3.1 Simple Oracle Reductions</h1>
<p>We start by introducing a number of simple oracle reductions. </p>
<h2 id="a0000000013">3.1.1 Polynomial Equality Testing</h2>
<p>Context: two univariate polynomials \(P, Q \in \mathbb {F}[X]\) of degree at most \(d\), available as polynomial evaluation oracles </p>
<p>Input relation: \(P = Q\) as polynomials </p>
<p>Protocol type: a single message of type \(\mathbb {F}\) from the verifier to the prover. </p>
<p>Honest prover: does nothing </p>
<p>Honest verifier: checks that \(P(r) = Q(r)\) </p>
<p>Output relation: \(P(r) = Q(r)\) </p>
<p>Extractor: trivial since there is no witness </p>
<p>Completenes: trivial </p>
<p>Round-by-round state function: corresponds precisely to input and output relation </p>

<p>Round-by-round error: \(d / \lvert \mathbb {F} \rvert \) </p>
<p>Round-by-round knowledge soundness: follows from Schwartz-Zippel </p>
<p>To summarize, we have the following judgment: </p>
<div class="displaymath" id="a0000000029">
  \[  \begin{array}{c} \Psi := (); \;  \Theta := (P, Q); \;  \Sigma := (); \;  \tau := (\mathsf{V2P}, \mathbb {F}) \vdash \\[1ex] \{ P = Q\}  \quad \left( \begin{array}{l} \mathcal{P} := (), \\ \mathcal{V} := (P,Q,r) \mapsto [P(r) \stackrel{?}{=} Q(r)], \\ \mathcal{E} := () \end{array} \right)^{\emptyset } \quad \{ \! \! \{ P(r) = Q(r); \mathsf{St}_{P,Q}; \frac{d}{\lvert \mathbb {F} \rvert }\} \! \! \}  \end{array}  \]
</div>
<p> where \(\mathsf{St}(i) = \begin{cases} \end{cases} P \stackrel{?}{=} Q \text{ if } i = 0 \\ P(r) \stackrel{?}{=} Q(r) \text{ if } i = 1 \end{cases}\) </p>
<h2 id="a0000000014">3.1.2 Batching Polynomial Evaluation Claims</h2>
<p>Context: \(n\)-tuple of values \(v = (v_1, \ldots , v_n) \in \mathbb {F}^n\) </p>
<p>Protocol type: one message of type \(\mathbb {F}^k\) from the verifier to the prover, and another message of type \(\mathbb {F}\) from the prover to the verifier </p>
<p>Auxiliary function: a polynomial map \(E : \mathbb {F}^k \to \mathbb {F}^n\) </p>
<p>Honest prover: given \(r \gets \mathbb {F}^k\) from the verifier’s message, computes \(\langle E(r), v\rangle := E(r)_1 \cdot v_1 + \cdots + E(r)_n \cdot v_n\) and sends it to the verifier </p>
<p>Honest verifier: checks that the received value \(v'\) is equal to \(\langle E(r), v\rangle \) </p>
<p>Extractor: trivial since there is no witness </p>
<p>Security: depends on the degree &amp; non-degeneracy of the polynomial map \(E\) </p>
<h1 id="sec:sumcheck">3.2 The Sum-Check Protocol</h1>

<p>In this section, we describe the sum-check protocol&#160;<span class="cite">
	[
	<a href="sect0002.html#sumcheck-protocol" >1</a>
	]
</span> in a modular manner, as a running example for our approach to specifying and proving properties of oracle reductions (based on a program logic approach). </p>
<p>The sum-check protocol, as described in the original paper and many expositions thereafter, is a protocol to reduce the claim that </p>
<div class="displaymath" id="a0000000030">
  \[  \sum _{x \in \{ 0, 1\} ^n} P(x) = c,  \]
</div>
<p> where \(P\) is an \(n\)-variate polynomial of certain individual degree bounds, and \(c\) is some field element, to the claim that </p>
<div class="displaymath" id="a0000000031">
  \[  P(r) = v,  \]
</div>
<p> for some claimed value \(v\) (derived from the protocol transcript), where \(r\) is a vector of random challenges from the verifier sent during the protocol. </p>
<p>In our language, the initial context of the sum-check protocol is the pair \((P, c)\), where \(P\) is an oracle input and \(c\) is public. The protocol proceeds in \(n\) rounds of interaction, where in each round \(i\) the prover sends a univariate polynomial \(s_i\) of bounded degree and the verifier sends a challenge \(r_i \gets \mathbb {F}\). The honest prover would compute </p>
<div class="displaymath" id="a0000000032">
  \[  s_i(X) = \sum _{x \in \{ 0, 1\} ^{n - i - 1}} P(r_1, \ldots , r_{i - 1}, X, x),  \]
</div>
<p> and the honest verifier would check that \(s_i(0) + s_i(1) = s_{i - 1}(r_{i - 1})\), with the convention that \(s_0(r_0) = c\). </p>
<div class="theorem_thmwrapper theorem-style-plain" id="a0000000033">
  <div class="theorem_thmheading">
    <span class="theorem_thmcaption">
    Theorem
    </span>
    <span class="theorem_thmlabel">18</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-proof_systems.html#a0000000033">#</a>
    
    
    
        </div>
  </div>
  <div class="theorem_thmcontent">
  <p>The sum-check protocol is complete. </p>

  </div>
</div>
<p>We now proceed to break down this protocol into individual message, and then specify the predicates that should hold before and after each message is exchanged. </p>
<p>First, it is clear that we can consider each round in isolation. In fact, each round can be seen as an instantiation of the following simpler "virtual" protocol: </p>
<ol class="enumerate">
  <li><p>In this protocol, the context is a pair \((p, d)\), where \(p\) is now a <em>univariate</em> polynomial of bounded degree. The predicate / relation is that \(p(0) + p(1) = d\). </p>
</li>
  <li><p>The prover first sends a univariate polynomial \(s\) of the same bounded degree as \(p\). In the honest case, it would just send \(p\) itself. </p>
</li>
  <li><p>The verifier samples and sends a random challenge \(r \gets \mathbb {F}\). </p>
</li>
  <li><p>The verifier checks that \(s(0) + s(1) = d\). The predicate on the resulting output context is that \(p(r) = s(r)\). </p>
</li>
</ol>
<p>The reason why this simpler protocol is related to a sum-check round is that we can <em>emulate</em> the simpler protocol using variables in the context at the time: </p>
<ul class="itemize">
  <li><p>The univariate polynomial \(p\) is instantiated as \(\sum _{x \in \{ 0, 1\} ^{n - i - 1}} P(r_1, \ldots , r_{i - 1}, X, x)\). </p>
</li>
  <li><p>The scalar \(d\) is instantiated as \(c\) if \(i = 0\), and as \(s_{i - 1}(r_{i - 1})\) otherwise. </p>
</li>
</ul>
<p>It is "clear" that the simpler protocol is perfectly complete. It is sound (and since there is no witness, also knowledge sound) since by the Schwartz-Zippel Lemma, the probability that \(p \ne s\) and yet \(p(r) = s(r)\) for a random challenge \(r\) is at most the degree of \(p\) over the size of the field. </p>
<p>Note that there is no witness so knowledge soundness follows trivially from soundness. Moreover, we can define the following state function for the simpler protocol: </p>
<ol class="enumerate">
  <li><p>The initial state funtion is the same as the predicate on the initial context, namely that \(p(0) + p(1) = d\). </p>
</li>
  <li><p>The state function after the prover sends \(s\) is the predicate that \(p(0) + p(1) = d\) and \(s(0) + s(1) = d\). Essentially, we add in the verifier’s check. </p>
</li>
  <li><p>The state function for the output context (after the verifier sends \(r\)) is the predicate that \(s(0) + s(1) = d\) and \(p(r) = s(r)\). </p>
</li>
</ol>
<p> Seen in this light, it should be clear that the simpler protocol satisfies round-by-round soundness. </p>
<p>In fact, we can break down this simpler protocol even more: consider the two sub-protocols that each consists of a single message. Then the intermediate state function is the same as the predicate on the intermediate context, and is given in a "strongest post-condition" style where it incorporates the verifier’s check along with the initial predicate. We can also view the final state function as a form of "canonical" post-condition, that is implied by the previous predicate except with small probability.  </p>
<h1 id="a0000000015">3.3 The Spartan Protocol</h1>
<h1 id="a0000000016">3.4 The Ligero Polynomial Commitment Scheme</h1>

</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="chap-oracle_reductions.html" title="Oracle Reductions"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Formally Verified SNARKs in Lean"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="chap-commitment_schemes.html" title="Commitment Schemes"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>