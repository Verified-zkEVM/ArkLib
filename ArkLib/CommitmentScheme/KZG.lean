/-
Copyright (c) 2025 ArkLib Contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Quang Dao
-/

import ArkLib.AGM.Basic
import Mathlib.Algebra.Field.ZMod
import Mathlib.Algebra.Order.Star.Basic
import Mathlib.Algebra.Polynomial.FieldDivision
import Mathlib.RingTheory.Polynomial.Basic

/-! ## The KZG Polynomial Commitment Scheme -/

open Polynomial

namespace KZG

variable {G : Type*} [CommGroup G] {p : ℕ} [hp : Fact (Nat.Prime p)] (hpG : Nat.card G = p)
  {g : G}

variable {G₁ : Type*} [CommGroup G₁] {g₁ : G₁}
  {G₂ : Type*} [CommGroup G₂] {g₂ : G₂}
  {Gₜ : Type*} [CommGroup Gₜ]
  -- TODO: need to make this a `ZMod p`-linear map
  (pairing : (Additive G₁) →ₗ[ℤ] (Additive G₂) →ₗ[ℤ] (Additive Gₜ))

/-- The vector of length `n + 1` that consists of powers:
  `#v[1, g, g ^ a.val, g ^ (a.val ^ 2), ..., g ^ (a.val ^ n)` -/
def towerOfExponents (g : G) (a : ZMod p) (n : ℕ) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

variable {n : ℕ}

/-- The `srs` (structured reference string) for the KZG commitment scheme with secret exponent `a`
    is defined as `#v[g₁, g₁ ^ a, g₁ ^ (a ^ 2), ..., g₁ ^ (a ^ (n - 1))], #v[g₂, g₂ ^ a]` -/
def generateSrs (n : ℕ) (a : ZMod p) : Vector G₁ (n + 1) × Vector G₂ 2 :=
  (towerOfExponents g₁ a n, towerOfExponents g₂ a 1)

/-- One can verify that the `srs` is valid via using the pairing -/
def checkSrs (proveSrs : Vector G₁ (n + 1)) (verifySrs : Vector G₂ 2) : Prop :=
  ∀ i : Fin n,
    pairing (proveSrs[i.succ]) (verifySrs[0]) = pairing (proveSrs[i.castSucc]) (verifySrs[1])

/-- To commit to an `n`-tuple of coefficients `coeffs` (corresponding to a polynomial of degree less
    than `n`), we compute: `∏ i : Fin n, srs[i] ^ (p.coeff i)` -/
def commit (srs : Vector G₁ n) (coeffs : Fin n → ZMod p) : G₁ :=
  ∏ i : Fin n, srs[i] ^ (coeffs i).val

/-- When committing `coeffs` using `srs` generated by `towerOfExponents`, and `coeffs` correspond to
  a polynomial `poly : (ZMod p)[X]` of degree `< n + 1`, we get the result `g₁ ^ (p.eval a).val` -/
theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G₁ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g₁ a n) (degreeLTEquiv _ _ poly) = g₁ ^ (poly.1.eval a).val := by
  have {g₁ : G₁} (a b : ℕ) : g₁^a = g₁^b ↔ g₁^(a : ℤ) = g₁^(b : ℤ) := by
    simp only [zpow_natCast]
  simp only [commit, towerOfExponents, Fin.getElem_fin, Vector.getElem_ofFn]
  simp_rw [← pow_mul, Finset.prod_pow_eq_pow_sum,
    eval_eq_sum_degreeLTEquiv poly.property,
      this,
      ←orderOf_dvd_sub_iff_zpow_eq_zpow]

  have hordg₁ : g₁ = 1 ∨ orderOf g₁ = p := by
    have ord_g₁_dvd : orderOf g₁ ∣ p := by rw [← hpG1]; apply orderOf_dvd_natCard
    rw [Nat.dvd_prime hp.out, orderOf_eq_one_iff] at ord_g₁_dvd
    exact ord_g₁_dvd

  rcases hordg₁ with ord1 | ordp
  · simp [ord1]
  · simp [ordp, ←ZMod.intCast_eq_intCast_iff_dvd_sub]
    apply Fintype.sum_congr
    intro x
    exact mul_comm _ _

/-- To generate an opening proving that a polynomial `poly` has a certain evaluation at `z`,
  we return the commitment to the polynomial `q(X) = (poly(X) - poly.eval z) / (X - z)` -/
noncomputable def generateOpening [Fact (Nat.Prime p)] (srs : Vector G₁ (n + 1))
    (coeffs : Fin (n + 1) → ZMod p) (z : ZMod p) : G₁ :=
  letI poly : degreeLT (ZMod p) (n + 1) := (degreeLTEquiv (ZMod p) (n + 1)).invFun coeffs
  letI q : degreeLT (ZMod p) (n + 1) :=
    ⟨Polynomial.div (poly.val - C (poly.val.eval z)) (X - C z), by
      apply mem_degreeLT.mpr
      calc
      _ ≤ (poly.val - C (poly.val.eval z)).degree := Polynomial.degree_div_le _ _
      _ ≤ max poly.val.degree (C (poly.val.eval z)).degree := degree_sub_le poly.val _
      _ < n+1 := max_lt (mem_degreeLT.mp poly.property)
        (lt_of_lt_of_le (b := 1) (by simp [degree_C_lt]) (by norm_cast; omega))
      ⟩
  commit srs (degreeLTEquiv (ZMod p) (n + 1) q)

/-- To verify a KZG opening `opening` for a commitment `commitment` at point `z` with claimed
  evaluation `v`, we use the pairing to check "in the exponent" that `p(a) - p(z) = q(a) * (a - z)`,
  where `p` is the polynomial and `q` is the quotient of `p` at `z` -/
noncomputable def verifyOpening (verifySrs : Vector G₂ 2) (commitment : G₁) (opening : G₁)
    (z : ZMod p) (v : ZMod p) : Prop :=
  pairing (commitment / g₁ ^ v.val) (verifySrs[0]) = pairing opening (verifySrs[1] / g₂ ^ z.val)

-- p(a) - p(z) = q(a) * (a - z)
-- e ( C / g₁ ^ v , g₂ ) = e ( O , g₂ ^ a / g₂ ^ z)

-- theorem correctness {g : G} {a : ZMod p} {coeffs : Fin n → ZMod p} {z : ZMod p} :

end KZG
